# aiknowsys - Codebase Essentials

> **Last Updated:** January 29, 2026  
> **Purpose:** AI-Powered Development Workflow Template  
> **Maintainer:** arpa73

---

## 1. Technology Snapshot

| Component | Technology |
|-----------|------------|
| Runtime | Node.js 20+ |
| Language | JavaScript (ES Modules) ‚Üí TypeScript migration in progress |
| CLI Framework | Commander.js 14.x |
| User Prompts | Inquirer.js 13.x |
| Terminal UI | Chalk 5.x, Ora 9.x |
| Package Manager | npm |
| Distribution | npm registry |

---

## 2. Validation Matrix

| Command | Purpose | Expected |
|---------|---------|----------|
| `npm test` | Run unit tests | All 255+ tests pass |
| `npm run lint` | Lint codebase | No errors or warnings |
| `npm run test:coverage` | Code coverage | >80% coverage on lib/ |
| `node bin/cli.js --help` | CLI works | Shows help without errors |
| `node bin/cli.js scan --dir .` | Scan command | Generates draft ESSENTIALS |
| `node bin/cli.js check` | Validation + bloat detection | ESSENTIALS <800 lines |
| `node bin/cli.js validate-deliverables` | Deliverables validation | All checks pass |
| `node bin/cli.js validate-deliverables --full` | Comprehensive validation | All checks pass (includes fresh init) |
| `node bin/cli.js compress-essentials --analyze` | Preview compression | Shows opportunities |
| `npm pack --dry-run` | Package contents | Lists correct files |

---

## 3. Project Structure

```
aiknowsys/
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ cli.js              # CLI entry point
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ commands/           # Command implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init.js         # New project setup (entry point)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ init/           # Init command modules
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.js    # Barrel exports
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.js # Stack configs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts.js  # Interactive prompts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ display.js  # Output formatting
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ openspec.js # OpenSpec integration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scan.js         # Codebase scanner
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrate.js      # Migration workflow
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ install-agents.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ install-skills.js
‚îÇ   ‚îî‚îÄ‚îÄ utils.js            # Shared utilities
‚îú‚îÄ‚îÄ templates/              # All template files
‚îÇ   ‚îú‚îÄ‚îÄ agents/             # Agent templates
‚îÇ   ‚îú‚îÄ‚îÄ skills/             # Skill templates (user-facing only)
‚îÇ   ‚îú‚îÄ‚îÄ git-hooks/          # TDD git hooks
‚îÇ   ‚îú‚îÄ‚îÄ scripts/            # TDD install scripts
‚îÇ   ‚îú‚îÄ‚îÄ workflows/          # GitHub Actions workflows
‚îÇ   ‚îú‚îÄ‚îÄ hooks/              # VSCode session hooks (optional)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks.json      # Hook configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session-start.js # Auto-load context
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session-end.js  # Auto-save state
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation-reminder.cjs # Stop hook (validation enforcement)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tdd-reminder.cjs # PreToolUse hook (TDD reminders)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ collaboration-check.mjs # Concurrent work detection
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ performance-monitor.cjs # Performance tracking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migration-check.cjs # Version mismatch detection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ doc-sync.cjs # Documentation staleness tracking
‚îÇ   ‚îú‚îÄ‚îÄ stacks/             # Stack-specific templates
‚îÇ   ‚îú‚îÄ‚îÄ AGENTS.template.md
‚îÇ   ‚îú‚îÄ‚îÄ CODEBASE_ESSENTIALS.template.md
‚îÇ   ‚îú‚îÄ‚îÄ CODEBASE_ESSENTIALS.minimal.template.md
‚îÇ   ‚îî‚îÄ‚îÄ CODEBASE_CHANGELOG.template.md
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ skills/             # Universal skills (includes maintainer-only)
‚îÇ       ‚îú‚îÄ‚îÄ deliverable-review/  # Maintainer skill (maintainer: true)
‚îÇ       ‚îú‚îÄ‚îÄ _skill-template/     # Maintainer skill (maintainer: true)
‚îÇ       ‚îú‚îÄ‚îÄ ai-friendly-documentation/  # User skills (distributed)
‚îÇ       ‚îú‚îÄ‚îÄ context7-usage/
‚îÇ       ‚îú‚îÄ‚îÄ dependency-management/
‚îÇ       ‚îú‚îÄ‚îÄ feature-implementation/
‚îÇ       ‚îú‚îÄ‚îÄ refactoring-workflow/
‚îÇ       ‚îú‚îÄ‚îÄ skill-creator/
‚îÇ       ‚îú‚îÄ‚îÄ skill-validation/
‚îÇ       ‚îú‚îÄ‚îÄ tdd-workflow/
‚îÇ       ‚îî‚îÄ‚îÄ validation-troubleshooting/
‚îú‚îÄ‚îÄ .aiknowsys/             # AI knowledge system (user workspace)
‚îÇ   ‚îú‚îÄ‚îÄ performance-history.json # Performance tracking (gitignored, last 100 runs)
‚îÇ   ‚îú‚îÄ‚îÄ CURRENT_PLAN.md     # Team index (auto-generated by sync-plans)
‚îÇ   ‚îú‚îÄ‚îÄ PLAN_*.md           # Implementation plans
‚îÇ   ‚îú‚îÄ‚îÄ plans/              # Multi-developer plan tracking (committed)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.md       # Workflow explanation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ active-<username>.md  # Per-developer active plan pointer
‚îÇ   ‚îú‚îÄ‚îÄ reviews/            # Multi-developer reviews (gitignored)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.md       # Workflow explanation (committed)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PENDING_<username>.md  # Per-developer review files
‚îÇ   ‚îú‚îÄ‚îÄ learned/            # Project-specific patterns (committed)
‚îÇ   ‚îú‚îÄ‚îÄ personal/           # Personal patterns (gitignored)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ <username>/     # Per-developer personal patterns
‚îÇ   ‚îî‚îÄ‚îÄ sessions/           # Session notes (gitignored)
‚îú‚îÄ‚îÄ scripts/                # Utility bash scripts (cleanup, maintenance)
‚îú‚îÄ‚îÄ examples/               # Stack-specific examples
‚îú‚îÄ‚îÄ docs/                   # Documentation
‚îî‚îÄ‚îÄ package.json
```

### Maintainer vs User Content

Skills with `maintainer: true` in frontmatter are for AIKnowSys development only.
They stay in `.github/skills/` but are NOT synced to `templates/skills/`.

**User skills (10):** Distributed via `npx aiknowsys init`  
**Maintainer skills (2):** `deliverable-review`, `_skill-template`

---

## 4. Core Patterns

### CLI Command Structure
```javascript
// All commands follow this pattern:
import { createLogger } from '../logger.js';

export async function commandName(options) {
  const targetDir = path.resolve(options.dir);
  const silent = options._silent || false;
  const log = createLogger(silent);
  
  // 1. Display header
  log.header('Command Title', 'üéØ');
  
  // 2. Interactive prompts (if needed, skip if silent)
  if (!silent) {
    const answers = await inquirer.prompt([...]);
  }
  
  // 3. Spinner for long operations (conditional on silent mode)
  const spinner = silent ? null : ora('Doing work...').start();
  
  // 4. Execute logic
  try {
    // ... work
    if (spinner) spinner.succeed('Done');
    
    // Return data for test assertions
    return { success: true, data: result };
  } catch (error) {
    if (spinner) spinner.fail('Failed');
    log.error('Failed: ' + error.message);
    throw error;  // Testable - don't use process.exit()
  }
  
  // 5. Display next steps
  log.cyan('üìñ Next steps:');
}
```

### Logger Pattern
All commands use `createLogger(silent)` for consistent, testable output. See [learned skill](.aiknowsys/learned/logger-pattern.md) for detailed usage, methods, and examples.

```javascript
import { createLogger } from '../logger.js';
const log = createLogger(silent);  // silent = true/false
```

### Inquirer Prompts
Use `'rawlist'` instead of `'list'` for VS Code terminal compatibility. See [learned skill](.aiknowsys/learned/inquirer-compatibility.md) for details.

```javascript
// Use rawlist (numbered options) - works everywhere
await inquirer.prompt([{
  type: 'rawlist',
  name: 'choice',
  message: 'Select option:',
  choices: [...],
  default: 1
}]);
```

### Template Variable Replacement
```javascript
// Use {{VARIABLE}} syntax in templates
copyTemplate(source, dest, {
  '{{PROJECT_NAME}}': answers.projectName,
  '{{DATE}}': new Date().toLocaleDateString(...)
});
```

### Silent Mode for Nested Calls
```javascript
// Commands accept _silent option for programmatic use
export async function installAgents(options) {
  const silent = options._silent || false;
  if (!silent) {
    console.log(...);
  }
}
```

### Progress Indicators
For detailed guidance on progress indicators and spinners, see the [learned skill](.aiknowsys/learned/progress-indicators.md). This project uses ora spinners with three distinct patterns depending on the operation type (file processing, multi-step checks, or sequential phases). Always call `succeed()`, `fail()`, or `info()` to clear spinner state.

### Plan Management Pattern
**Multiple concurrent plans** enabled via pointer system.

**Multi-Developer Workflow (Mandatory v0.9.0+):**

**Plan Pointers:**
- **plans/active-<username>.md:** Personal active plan pointer (committed to git)
- **CURRENT_PLAN.md:** Team index aggregating all developers' plans (auto-generated, committed)
- **Username:** Extracted from `git config user.name`, normalized (lowercase, spaces ‚Üí hyphens)

**Individual Plans (.aiknowsys/PLAN_*.md):**
- Full implementation details (committed to git)
- Progress tracking with checkboxes
- Phase/step breakdown
- Status lifecycle: üìã PLANNED ‚Üí üéØ ACTIVE ‚Üí üîÑ PAUSED or ‚úÖ COMPLETE or ‚ùå CANCELLED

**Workflow:**
1. **@Planner** creates detailed PLAN_*.md
2. **Developer** updates `plans/active-<username>.md` to point to plan
3. **Developer** runs `npx aiknowsys sync-plans` to regenerate team index
4. **Developer** follows active plan, tracking progress in PLAN_*.md
5. **Completed plans** remain visible in team index with ‚úÖ status

**Benefits:**
- No merge conflicts on plan tracking (each dev has own pointer)
- Team visibility (CURRENT_PLAN.md shows everyone's active work)
- Solo developers work the same way (just one entry in team index)
- Clean git history (auto-generated file committed, not manually edited)

**Migration:**
- **Existing projects (pre-v0.9.0):** Run `npx aiknowsys migrate-to-multidev` to convert single-dev ‚Üí multi-dev
- **New projects:** Run `npx aiknowsys init` (creates multi-dev structure by default)

See: [AGENTS.md](AGENTS.md#plan-management)

### Pattern Sharing Workflow

**Personal vs Learned Patterns:**
- **personal/<username>/** - Private patterns (gitignored, individual discoveries)
- **learned/** - Team patterns (committed, shared knowledge)

**Sharing Mechanism:**
- AI agents suggest sharing valuable personal patterns
- Pattern files move from personal/ ‚Üí learned/ with updated frontmatter
- Duplicate detection prevents redundant patterns
- Merge workflow combines similar patterns intelligently

**Trigger words:** "share pattern", "share with team", "what patterns can I share"

**Automated workflow:**
1. Agent detects valuable pattern (high usage, solves recurring problem)
2. Checks learned/ for duplicates (title, keywords, content overlap)
3. If unique: Moves to learned/, updates frontmatter (adds shared_by, shared_date)
4. If duplicate: Offers merge or keep separate
5. Updates session notes, suggests commit

**Benefits:**
- Knowledge captured naturally during development
- No manual "learn" command needed (AI-assisted)
- Duplicate prevention reduces pattern bloat
- Merge intelligence combines related discoveries
- Team collaboration without meetings

See: [.github/skills/pattern-sharing/SKILL.md](.github/skills/pattern-sharing/SKILL.md)

---

## 4a. TypeScript Patterns (Since v0.9.0)

### Build System

**Commands:**
```bash
npm run build         # Compile TypeScript ‚Üí dist/ (prod)
npm run build:watch   # Watch mode for development
npm run dev           # Alias for build:watch
npm run type-check    # Check types without building (CI)
```

**Build Pipeline:**
```
lib/              # TypeScript source (.ts files)
  ‚Üì tsc build
dist/             # Compiled output (.js, .d.ts, .js.map)
  ‚Üì npm test (pretest: npm run build)
Test against      # Tests validate compiled code
  ‚Üì npm publish (prepublishOnly: build + lint + test)
Users get dist/   # Compiled JavaScript only
```

### Type System Configuration

**tsconfig.json settings:**
```json
{
  "compilerOptions": {
    "strict": true,              // All strict checks enabled
    "target": "ES2022",          // Modern JavaScript features
    "module": "ES2022",          // ES modules
    "moduleResolution": "node",  
    "esModuleInterop": true,     
    "outDir": "./dist",          // Compiled output
    "declaration": true,         // Generate .d.ts files
    "declarationMap": true,      // Source maps for types
    "sourceMap": true            // JavaScript source maps
  },
  "include": ["lib/**/*", "bin/**/*", "test/**/*"],
  "exclude": ["node_modules", "dist", "templates"]
}
```

### Import Patterns

**CRITICAL: Use `.js` extensions in imports (TypeScript quirk for ES modules)**

```typescript
// ‚úÖ Correct: .js extension (required for ES modules)
import { validateDeliverables } from './commands/validate-deliverables.js';
import { createLogger } from './logger.js';

// ‚úÖ Correct: Type-only import
import type { ValidationResult, FileOperation } from './types/index.js';

// ‚ùå Wrong: .ts extension
import { utils } from './utils.ts';  // Will fail at runtime!

// ‚ùå Wrong: No extension
import { config } from './config';   // Module resolution error
```

**Why `.js` extensions?**  
TypeScript compiles `.ts` ‚Üí `.js`, but import paths are NOT rewritten. Runtime needs `.js` to find the compiled file.

### Type Definitions

**Core types location:** `lib/types/index.ts`

```typescript
// File operation result
export interface FileOperation {
  source: string;
  destination: string;
  status: 'success' | 'skipped' | 'error';
  reason?: string;
}

// Validation result
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
}

// Command options (extends Commander.js options)
export interface CommandOptions {
  dir?: string;
  force?: boolean;
  silent?: boolean;
  _silent?: boolean;  // Internal flag for nested calls
}
```

### Type Safety Patterns

**Critical Invariants:**
- ‚úÖ All new code MUST be TypeScript (not JavaScript)
- ‚úÖ Use `.js` extensions in imports
- ‚úÖ Avoid `any` - use `unknown` for truly dynamic data
- ‚úÖ Write tests before implementation (TDD with types)
- ‚úÖ Type-only imports for interfaces/types

**Avoid `any`:**
```typescript
// ‚ùå Bad: Loses all type safety
function process(data: any) {
  data.anything();  // No error, but might crash
}

// ‚úÖ Better: Unknown with type guards
function process(data: unknown) {
  if (typeof data === 'string') {
    console.log(data.toUpperCase());  // TypeScript knows it's string
  } else if (isValidationResult(data)) {
    console.log(data.errors);  // TypeScript knows the shape
  }
}

// Type guard function
function isValidationResult(obj: unknown): obj is ValidationResult {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'valid' in obj &&
    'errors' in obj
  );
}
```

**Type-only imports:**
```typescript
// ‚úÖ Single type import
import type { ValidationResult } from './types/index.js';

// ‚úÖ Multi-line type-only imports (for many types from same module)
import type { 
  TemplateSchemaMap, 
  LegacyPattern, 
  AutoFixPattern,
  DeliverableValidationOptions,
  DeliverableValidationResult,
  ValidationCheck
} from './types/index.js';

// ‚úÖ Mixed import/type
import { validateFile } from './validator.js';
import type { FileOperation } from './types/index.js';

// ‚ùå Unnecessary: Importing only for types but not marked as type-only
import { ValidationResult } from './types/index.js';  // Could be optimized
```

### TDD with TypeScript

**Development workflow:**

1. **RED: Write failing test FIRST (with types)**
   ```typescript
   // test/commands/validate.test.ts
   import type { ValidationResult } from '../../lib/types/index.js';
   import { validateDeliverables } from '../../lib/commands/validate-deliverables.js';
   
   it('should detect missing files', async () => {
     const result: ValidationResult = await validateDeliverables({ dir: './test/fixtures/missing' });
     expect(result.valid).toBe(false);
     expect(result.errors).toContain('AGENTS.md not found');
   });
   ```

2. **GREEN: Implement minimal code to pass**
   ```typescript
   // lib/commands/validate-deliverables.ts
   import type { ValidationResult } from '../types/index.js';
   
   export async function validateDeliverables(options: CommandOptions): Promise<ValidationResult> {
     const errors: string[] = [];
     
     if (!fs.existsSync(path.join(options.dir, 'AGENTS.md'))) {
       errors.push('AGENTS.md not found');
     }
     
     return { valid: errors.length === 0, errors, warnings: [] };
   }
   ```

3. **REFACTOR: Clean up while keeping tests green**
   - Extract validation logic to separate functions
   - Add more specific type definitions
   - Improve error messages

### TypeScript Suppressions

**When to use error suppressions during incremental migration:**

```typescript
// ‚úÖ BEST: @ts-expect-error (fails if error goes away)
// @ts-expect-error - quality-checkers not yet migrated to TypeScript
import { checkEssentialsBloat } from '../../lib/quality-checkers/essentials-bloat.js';

// ‚ö†Ô∏è AVOID: @ts-ignore (hides all errors, even new ones)
// @ts-ignore
import { something } from './unmigrated.js';  // Don't use this!

// ‚ö†Ô∏è AVOID: Type assertions (no runtime safety)
const result = response as ValidationResult;  // Dangerous if wrong!
```

**Why @ts-expect-error is best:**
- ‚úÖ Documents WHY the error is expected (with comment)
- ‚úÖ Fails compilation if error is fixed (prevents stale suppressions)
- ‚úÖ Scoped to specific line (doesn't hide other errors)
- ‚úÖ Shows progress (remove when module migrated)

**When to use @ts-expect-error:**
- Importing unmigrated JavaScript modules during incremental migration
- Temporary workaround for known type issues in dependencies
- Testing edge cases that intentionally cause type errors

**When NOT to use:**
- ‚ùå To bypass legitimate type errors (fix the types instead!)
- ‚ùå In production code (only acceptable in tests during migration)
- ‚ùå Without explanatory comment (always explain WHY)

### Typing Unmigrated Modules

**Pattern for typing JavaScript modules not yet migrated:**

```typescript
// ‚úÖ Use ReturnType<typeof> for function return types
import { createLogger } from '../logger.js';  // Still .js (not migrated)

type Logger = ReturnType<typeof createLogger>;  // Extract return type

function myCommand(log: Logger) {  // Now type-safe!
  log.success('Command completed');
  log.error('Something failed');
}
```

**Why this works:**
- TypeScript infers return type from JavaScript function
- No need to create manual interface (DRY principle)
- Automatically updates when JS function changes
- Works with unmigrated modules during incremental migration

**Other utility types for migration:**
```typescript
// Get parameter types from unmigrated function
type Params = Parameters<typeof unmigrated>;

// Get return type from unmigrated async function  
type AsyncReturn = Awaited<ReturnType<typeof asyncFn>>;

// Get instance type from unmigrated class
type Instance = InstanceType<typeof MyClass>;
```

### Common TypeScript Gotchas

**Module resolution:**
```typescript
// ‚ùå This works in TypeScript but fails at runtime
import { config } from './config';

// ‚úÖ Always use .js extension
import { config } from './config.js';
```

**Type assertions:**
```typescript
// ‚ùå Unsafe: Might be wrong at runtime
const result = response as ValidationResult;

// ‚úÖ Better: Type guard with runtime check
function isValidationResult(obj: unknown): obj is ValidationResult {
  return /* runtime validation */;
}

if (isValidationResult(result)) {
  // Safe to use result.errors, result.warnings
}
```

**Async/await:**
```typescript
// ‚úÖ Always type Promise return
export async function runCommand(options: CommandOptions): Promise<ValidationResult> {
  // ...
}

// ‚ùå Don't forget await (TypeScript catches this)
const result = runCommand(options);  // Error: result is Promise<ValidationResult>, not ValidationResult
```

### Distribution

**Package contents:**
- ‚úÖ `dist/` - Compiled JavaScript (.js, .d.ts, .js.map)
- ‚úÖ `templates/` - User-facing files
- ‚úÖ `bin/` - CLI entry point
- ‚ùå `lib/` - TypeScript source (excluded from npm package)
- ‚ùå `test/` - Test files (excluded)

**Why ship `dist/` not `lib/`?**
- Users don't need TypeScript compiler
- Faster execution (no runtime compilation)
- Industry standard for TypeScript packages

### Migration Status

- ‚úÖ Phase 1: Infrastructure complete
- ‚úÖ Phase 2: Core type definitions complete
- ‚úÖ Phase 3: Core utilities migrated
- ‚úÖ Phase 4: All 40 test files migrated to TypeScript
- ‚úÖ Phase 5: Build integration complete
- ‚è≥ Phase 6: Documentation updates in progress
- ‚èπÔ∏è Phase 7: Template schema enforcement (pending)

---

## 5. Critical Invariants

1. **ES Modules Only**
   - All **internal** files use `import`/`export`, never `require()`
   - package.json has `"type": "module"`
   - **Exception:** Templates distributed to user projects may use `.cjs` for compatibility
     - Example: VSCode hooks, git hook installer
     - Reason: User projects may not use ES modules

2. **Absolute Paths Required**
   - Always use `path.resolve()` for user-provided paths
   - Use `getPackageDir()` for template paths

3. **Graceful Failures**
   - All commands must handle missing files/directories
   - Show helpful error messages, not stack traces

4. **Template Preservation**
   - Never modify files in `templates/` - they're the source of truth
   - User customization happens in generated files

5. **Template Structure Integrity**
   - When AI fills CODEBASE_ESSENTIALS.md, NEVER change section headings
   - Replace `{{PLACEHOLDERS}}` with real values, not generic placeholders
   - Preserve template structure exactly (don't rename sections)
   - Example: Keep "Testing Patterns" as-is, don't change to "Testing Guidelines"
   - Example: Replace `{{TEST_ORGANIZATION}}` with actual test structure, not "Manual testing only"

6. **Backwards Compatibility**
   - Bash scripts in `scripts/` must remain functional
   - npm CLI is additive, not replacement

7. **Test-Driven Development (TDD)**
   - **For new features:** Write tests BEFORE implementation (RED ‚Üí GREEN ‚Üí REFACTOR)
   - **For bugfixes:** Write test that reproduces bug FIRST (should fail), then fix bug (test passes), then refactor
   - Follow RED-GREEN-REFACTOR cycle for both features and bugs
   - Keep tests fast and focused
   - **Why TDD for bugs:** Ensures bug is reproducible, confirms fix works, prevents regression
   - **Exception:** Configuration-only changes (e.g., adding properties to const objects) don't require new tests if existing tests already cover the logic using that configuration
   - See `.github/skills/tdd-workflow/SKILL.md` for detailed guidance
   - See [Test-Driven Bugfixing](https://evolveum.com/test-driven-bugfixing/) for bugfix workflow

8. **Deliverables Consistency**
   - Templates (`templates/` directory) are **deliverables** distributed to users
   - ANY change to core functionality MUST update corresponding templates
   - Templates must match non-template equivalents (agents, workflows, docs)
   - Breaking changes MUST be reflected in all deliverables before release
   - **Validation:**
     - Run `npx aiknowsys validate-deliverables` before commits/releases
     - Pre-commit hook automatically validates when templates/ changed
     - quality-check command includes deliverables validation
     - Use `--fix` flag to auto-fix simple pattern issues
   - **Critical:** Shipping broken templates breaks user experience
   - See [.aiknowsys/learned/deliverables-validation.md](.aiknowsys/learned/deliverables-validation.md) for patterns

---

## 6. Common Gotchas

See [learned skill](.aiknowsys/learned/common-gotchas.md) for detailed solutions to common issues:
- ESM `__dirname` not available (use `fileURLToPath(import.meta.url)`)
- Chalk 5.x is ESM-only (must use `import`, not `require()`)
- Template variables in markdown (use regex escaping)
- Path separators (always use `path.join()`, never string concatenation)
- Import extensions required (must include `.js`)
- JSON import syntax (use import assertions)
- **CommonJS in ES module projects**: Use `.cjs` extension when you need CommonJS (require/module.exports) in a project with `"type": "module"` in package.json. Example: VSCode hooks use `.cjs` because stdin JSON parsing is simpler with CommonJS than ES module async imports.

---

## 7. Extending AIKnowSys

For adding new commands or skills, see [learned skill](.aiknowsys/learned/extending-aiknowsys.md).

**Quick reference:**
- Commands: Create `lib/commands/my-command.js`, register in `bin/cli.js`, add tests
- Skills: Create `templates/skills/my-skill/SKILL.md`, register in `install-skills.js`
- Follow existing patterns, write tests first (TDD)

**Universal Learned Skills:**
- `plan-management.md` - Multi-plan concurrent workflow pattern
- `essentials-compression.md` - ESSENTIALS bloat detection and compression

### When to Document Where

**Add to CODEBASE_ESSENTIALS.md when:**
- Core architecture decision (technology choice)
- Universal pattern (all files of type X follow this)
- Critical invariant (cannot be violated)
- Project structure change (new directories, file organization)
- Core command/feature that ships with aiknowsys

**Add to .aiknowsys/learned/ when:**
- Project-specific discovery (specific to this codebase)
- Workaround for library/framework quirk
- Optional technique that improves quality
- Pattern that emerged from practice (not designed upfront)
- Error resolution that might recur

**Why this matters:** Keeps ESSENTIALS focused on architecture while allowing learned skills to capture project evolution. Target: ESSENTIALS <800 lines.

---

## 8. Testing Philosophy

We practice **Test-Driven Development (TDD)** for all new features. See [.github/skills/tdd-workflow/SKILL.md](.github/skills/tdd-workflow/SKILL.md) for detailed guidance.

**Quick summary:**
1. Write test first (RED) - Define expected behavior
2. Watch it fail - Verify test catches the issue
3. Implement minimal code (GREEN) - Make the test pass  
4. Refactor - Clean up while tests stay green

**Testing Standards:**
- **Test Runner:** Node.js built-in (`node:test`) - ZERO external dependencies
- **Assertion Library:** `node:assert` module
- **Structure:** `describe()` for test suites, `it()` for individual tests
- **Assertions:** Use `assert.strictEqual()`, `assert.ok()`, `assert.match()`, etc.
- **Mocking:** Use `beforeEach()` / `afterEach()` for setup/teardown

**Example test structure:**
```javascript
import { describe, it, beforeEach, afterEach } from 'node:test';
import assert from 'node:assert';

describe('Feature Name', () => {
  beforeEach(() => {
    // Setup
  });

  it('should do something specific', () => {
    const result = functionUnderTest();
    assert.strictEqual(result, expectedValue);
  });

  afterEach(() => {
    // Cleanup
  });
});
```

**Running tests:**
```bash
npm test                             # Run all tests
node --test test/init.test.js --watch  # Watch mode
```

**Bash Scripts:**
For testing bash utilities, see [bash-script-tdd](.aiknowsys/learned/bash-script-tdd.md) for comprehensive workflow using Node.js test runner.

### TDD Compliance Check (CI Workflow)

The `.github/workflows/tdd-compliance.yml` GitHub Action enforces TDD by detecting logic changes without corresponding tests. As of v0.9.0+, it includes **smart refactor detection** to prevent false positives.

**What it checks:**
- ‚úÖ **New logic** (functions, classes, control flow) ‚Üí **requires tests**
- ‚úÖ **Refactors** (renames, operator equivalence, imports, docs) ‚Üí **no tests needed**
- ‚úÖ **Config-only** changes (const object properties) ‚Üí **no tests needed**

**Refactor Detection Patterns:**

| Pattern | Score | Example | Why Safe |
|---------|-------|---------|----------|
| **Docs/comments only** | 100 | JSDoc updates, comment fixes | Never affects behavior |
| **Import reordering** | 100 | Moving imports, reordering statements | No logic change |
| **Operator equivalence** | +15 | `\|\|` ‚Üí `??` for defaults | Equivalent for non-falsy values |
| **Variable rename** | +10 | `log` ‚Üí `_log` (eslint fix) | Same function, new name |

**Threshold:** Score ‚â• 30 = "likely refactor" ‚Üí skip test requirement

**How it works:**
1. Detects lib/ changes
2. For each file, calculates refactor score
3. If score ‚â• 30 ‚Üí refactor (no tests needed)
4. If score < 30 + logic keywords ‚Üí new logic (tests required)
5. Provides clear feedback (refactor vs logic)

**Example outputs:**
```bash
# Refactor detected (PASS)
‚úÖ REFACTOR DETECTED - TDD check passed!
  - lib/commands/archive-plans.js: operator
  üí° TIP: Existing tests cover refactored code.

# New logic without tests (FAIL)
‚ùå TDD VIOLATION DETECTED
Files with NEW LOGIC (need tests):
  - lib/commands/new-feature.js
```

**Testing the workflow:**
```bash
bash test/ci/tdd-check-test.sh  # Validate detection patterns
```

**See:** [Plan: Smart TDD Compliance Check](.aiknowsys/PLAN_tdd_check_refactor_detection.md) for implementation details

---

## 9. Release Checklist

- [ ] Bump version: `npm version patch/minor/major` (auto-updates package.json)
- [ ] Test all commands locally
- [ ] Run `npm pack --dry-run` to verify package contents
- [ ] Update CODEBASE_CHANGELOG.md
- [ ] `npm publish`

---

*This file is the single source of truth for AI assistants working on aiknowsys.*
